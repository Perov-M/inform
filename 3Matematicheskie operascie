Математика
Одной из основных функций микроконтроллера является выполнение вычислений, как с числами напрямую, так и со значениями переменных. Начнём погружение в мир математики с самых простых действий:

= присваивание
+ сложение
- вычитание
* умножение
/ деление
% остаток от деления
Рассмотрим простой пример:

int a = 10;
int b = 20;
int c = a + b;  // c = 30
int d = a * b;  // d = 200
// так тоже можно
d = d / a;      // d = 20
c = c * d;      // c = 600
По поводу последних двух строчек из примера, когда переменная участвует в расчёте своего собственного значения: существуют также составные операторы, укорачивающие запись:

+= составное сложение: a += 10 равносильно a = a + 10
-= составное вычитание: a -= 10 равносильно a = a - 10
*= составное умножение: a *= 10 равносильно a = a * 10
/= составное деление: a /= 10 равносильно a = a / 10
%= остаток от деления: a %= 10 равносильно a = a % 10
С их использованием можно сократить запись последних двух строчек из предыдущего примера:

d /= a;
c *= d;
Очень часто в программировании используется прибавление или вычитание единицы, для чего тоже есть короткая запись:

++ (плюс плюс) инкремент: a++ равносильно a = a + 1
-- (минус минус) декремент: a-- равносильно a = a - 1
Порядок записи инкремента играет очень большую роль: пост-инкремент var++ возвращает значение переменной до выполнения инкремента. Операция пре-инкремента ++var возвращает значение уже изменённой переменной. Пример:

byte a, b;
a = 10;
b = a++;
// a получит значение 11
// b получит значение 10
a = 10;
b = ++a;
// a получит значение 11
// b получит значение 11

Математические вычисления выполняются процессором некоторое время, оно зависит от типа данных и типа операции. Вот время выполнения (в микросекундах) не оптимизированных компилятором вычислений для Arduino Nano 16 МГц:

https://github.com/Perov-M/inform/blob/main/skorostb%20vblchisleniea.png

Операции с float выполняются гораздо дольше целочисленных, потому что в AVR нет аппаратной поддержки чисел с плавающей точкой и она реализована программно как сложная библиотека. В некоторых микроконтроллерах есть FPU - специальный аппаратный блок для вычислений с float.
Операции целочисленного деления на AVR выполняются дольше по той же причине - они реализованы программно, а вот умножение и сложение с вычитанием МК делает аппаратно и очень быстро.

Целочисленное деление
При целочисленном делении результат не округляется по "математическим" правилам, дробная часть просто отсекается, фактически это округление вниз: и 9/10 и 1/10 дадут 0. При использовании float само собой получится 0.9 и 0.1.
Если нужно целочисленное деление с округлением вверх, его можно реализовать так: вместо x / y записать (x + y - 1) / y. Рассмотренные выше примеры деления на 10 дадут результат 1.

Для округления по обычным математическим правилам можно использовать функцию round(), но она довольно тяжёлая, так работает с float.

Переполнение переменной
Вспомним предыдущий урок о типах данных: что будет с переменной, если её значение выйдет из допустимого диапазона? Тут всё весьма просто: при переполнении в бОльшую сторону из нового значения вычитается максимальное значение переменной,
и у неё остаётся только остаток. Для сравнения представим переменную как ведро. Будем считать, что при наливании воды и заполнении ведра мы скажем стоп, выльем из него всю воду, а затем дольём остаток. Вот так и с переменной, что останется - то останется.
Если переполнение будет несколько раз - несколько раз опорожним наше "ведро" и всё равно оставим остаток. Ещё один хороший пример - кружка Пифагора.

Особенность больших вычислений
Для сложения и вычитания по умолчанию используется ячейка 4 байта (long), но для умножения и деления - 2 байта (int). Если при умножении или делении в текущем действии результат превысит 32768 - ячейка переполнится и мы получим некорректный результат. 
Для исправления ситуации нужно привести тип переменной к long перед вычислением, что заставит МК выделить дополнительную память. Например  a = (long)b * c;

Для цифр существуют модификаторы, делающие то же самое:

U или u - перевод в uint16_t (от 0 до 65'535). Пример: 36000u
L или l - перевод в int32_t (-2 147 483 648… 2 147 483 647). Пример: 325646L
UL или ul - перевод в uint32_t (от 0 до 4 294 967 295). Пример: 361341ul

Особенности float
Помимо медленных вычислений, поддержка работы с float занимает много памяти, т.к. реализована в виде "библиотеки". Использование математических операций с float однократно добавляет примерно 1.5 кБ в память программы.

С вычислениями есть такая особенность: если в выражении нет float чисел, то вычисления будут иметь целый результат (дробная часть отсекается). Для получения правильного результата нужно писать преобразование (float) перед действием, 
использовать float числа или float переменные.
Также есть модификатор f, который можно применять только к цифрам float. Смысла в нём нет, но такую запись можно встретить. 
